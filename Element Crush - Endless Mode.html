<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Element Crush - Endless Swipe Mode</title>
<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: linear-gradient(to bottom right, #4b0082, #00008b);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  .game-container {
    background: white;
    border-radius: 16px;
    padding: 20px;
    max-width: 400px;
    width: 100%;
  }
  h1 {
    text-align: center;
    color: #6b21a8;
  }
  .grid {
    display: grid;
    gap: 5px;
    touch-action: none;
  }
  .cell {
    aspect-ratio: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: white;
    font-size: 20px;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.1s;
  }
  .cell:hover {
    transform: scale(1.05);
  }
  .info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
  }
  button {
    padding: 8px;
    border: none;
    border-radius: 6px;
    background: #6b21a8;
    color: white;
    font-weight: bold;
    cursor: pointer;
  }
  .game-over {
    text-align: center;
    font-size: 20px;
    color: red;
    margin-top: 10px;
  }
</style>
</head>
<body>
<div class="game-container">
  <h1>Element Crush</h1>
  <div class="info">
    <div>Score: <span id="score">0</span></div>
    <div>Moves w/o match: <span id="failMoves">0</span></div>
    <div>High Score: <span id="highScore">0</span></div>
  </div>
  <div id="grid" class="grid"></div>
  <button id="newGameBtn">New Game</button>
  <div id="gameOver" class="game-over"></div>
</div>

<script>
const ELEMENTS = ['H', 'He', 'Li', 'Be', 'C', 'N', 'O', 'F', 'Ne'];
const ELEMENT_INFO = {
  'H': 'special', 'He': 'helium', 'Li': 1, 'Be': 2, 'C': 14, 'N': 15, 'O': 16, 'F': 17, 'Ne': 'neon'
};
const GROUP_COLORS = {
  1: '#FF6B6B', 2: '#FFD93D', 13: '#6BCB77', 14: '#4D96FF',
  15: '#A78BFA', 16: '#FB7185', 17: '#06B6D4', 18: '#EC4899',
  'special': '#8B5CF6', 'helium': '#10B981', 'neon': '#F59E0B'
};

const COLS = 6;
const ROWS = 8;

let grid = [];
let score = 0;
let failMoves = 0;
let highScore = localStorage.getItem("highScore") || 0;

const scoreEl = document.getElementById('score');
const failMovesEl = document.getElementById('failMoves');
const highScoreEl = document.getElementById('highScore');
const gridEl = document.getElementById('grid');
const gameOverEl = document.getElementById('gameOver');
gridEl.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;

let startX, startY;

function initializeGrid() {
  grid = Array.from({ length: ROWS }, () => Array.from({ length: COLS }, () => ({
    element: ELEMENTS[Math.floor(Math.random() * ELEMENTS.length)],
    matched: false
  })));
  score = 0;
  failMoves = 0;
  gameOverEl.textContent = "";
  highScoreEl.textContent = highScore;
  updateUI();
  checkMatches();
}

function getElementColor(element) {
  const group = ELEMENT_INFO[element];
  return GROUP_COLORS[group] || '#ccc';
}

function updateUI() {
  scoreEl.textContent = score;
  failMovesEl.textContent = failMoves;
  highScoreEl.textContent = highScore;
  gridEl.innerHTML = '';

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = grid[r][c];
      const div = document.createElement('div');
      div.className = 'cell';
      div.textContent = cell.element;
      div.style.backgroundColor = getElementColor(cell.element);
      div.dataset.row = r;
      div.dataset.col = c;
      gridEl.appendChild(div);
    }
  }
}

function handleSwipe(r, c, direction) {
  if (gameOverEl.textContent) return;

  let r2 = r, c2 = c;
  if (direction === 'left') c2--;
  if (direction === 'right') c2++;
  if (direction === 'up') r2--;
  if (direction === 'down') r2++;

  if (r2 >= 0 && r2 < ROWS && c2 >= 0 && c2 < COLS) {
    [grid[r][c], grid[r2][c2]] = [grid[r2][c2], grid[r][c]];
    updateUI();
    const matched = checkMatches();
    if (!matched) {
      failMoves++;
      if (failMoves >= 3) {
        gameOverEl.textContent = "Game Over! No match in 3 moves.";
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("highScore", highScore);
        }
      }
    } else {
      failMoves = 0;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("highScore", highScore);
      }
    }
  }
}

function checkMatches() {
  let hasMatches = false;
  const matches = [];

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (c + 2 < COLS &&
          grid[r][c].element === grid[r][c+1].element &&
          grid[r][c].element === grid[r][c+2].element) {
        matches.push([r, c], [r, c+1], [r, c+2]);
        hasMatches = true;
      }
      if (r + 2 < ROWS &&
          grid[r][c].element === grid[r+1][c].element &&
          grid[r][c].element === grid[r+2][c].element) {
        matches.push([r, c], [r+1, c], [r+2, c]);
        hasMatches = true;
      }
    }
  }

  matches.forEach(([r, c]) => grid[r][c].matched = true);

  if (hasMatches) {
    score += matches.length * 10;
    fillEmpty();
    setTimeout(updateUI, 200);
    setTimeout(checkMatches, 300);
  }
  return hasMatches;
}

function fillEmpty() {
  for (let c = 0; c < COLS; c++) {
    for (let r = ROWS - 1; r >= 0; r--) {
      if (grid[r][c].matched) {
        for (let k = r; k > 0; k--) {
          grid[k][c] = grid[k-1][c];
        }
        grid[0][c] = {
          element: ELEMENTS[Math.floor(Math.random() * ELEMENTS.length)],
          matched: false
        };
      }
    }
  }
}

gridEl.addEventListener('touchstart', e => {
  const touch = e.touches[0];
  startX = touch.clientX;
  startY = touch.clientY;
});

gridEl.addEventListener('touchend', e => {
  const touch = e.changedTouches[0];
  const endX = touch.clientX;
  const endY = touch.clientY;

  const dx = endX - startX;
  const dy = endY - startY;

  const threshold = 30;
  if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;

  const cell = document.elementFromPoint(startX, startY);
  if (!cell || !cell.dataset.row) return;

  const r = parseInt(cell.dataset.row);
  const c = parseInt(cell.dataset.col);

  if (Math.abs(dx) > Math.abs(dy)) {
    handleSwipe(r, c, dx > 0 ? 'right' : 'left');
  } else {
    handleSwipe(r, c, dy > 0 ? 'down' : 'up');
  }
});

document.getElementById('newGameBtn').onclick = initializeGrid;

initializeGrid();
</script>
</body>
</html>